{"ok":true,"filename":"MainActivity.kt","content":"package com.example.toitoitour\n//////////////////////novo\nimport java.util.concurrent.TimeUnit\nimport android.util.Log\nimport android.location.Geocoder\nimport android.net.Uri\nimport android.os.Bundle\nimport android.os.Handler\nimport android.os.Looper\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.itemsIndexed\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport com.example.toitoitour.ui.theme.ToiToiTourTheme\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.*\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport okhttp3.*\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.RequestBody.Companion.asRequestBody\nimport org.json.JSONArray\nimport org.json.JSONObject\nimport java.io.File\nimport java.util.Locale\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.resumeWithException\nimport kotlinx.coroutines.suspendCancellableCoroutine\n\n// ✅ Places\nimport com.google.android.libraries.places.api.Places\nimport com.google.android.libraries.places.api.model.AutocompletePrediction\nimport com.google.android.libraries.places.api.model.Place\nimport com.google.android.libraries.places.api.net.FindAutocompletePredictionsRequest\nimport com.google.android.libraries.places.api.net.FetchPlaceRequest\nimport com.google.android.libraries.places.api.net.PlacesClient\n\n// =======================\n// === MODELS START ===\n// =======================\n// ----------------- PODACI ------------------\n\ndata class Stop(\n    val id: Int,\n    val title: String, // ulica + broj (ili cijela adresa)\n    val cityLine: String, // \"ZIP Grad\" (ako postoji)\n    val location: LatLng? = null,\n    val source: String = \"PDF\" // \"PDF\" ili \"GOOGLE\"\n)\n\nval demoStops: List<Stop> = emptyList()\n\n// =======================\n// === MODELS END ===\n// =======================\n\n// =======================\n// === ACTIVITY START ===\n// =======================\n// ----------------- ACTIVITY ------------------\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            ToiToiTourTheme {\n                ToiToiTourApp()\n            }\n        }\n    }\n}\n\n// =======================\n// === ACTIVITY END ===\n// =======================\n\n// =======================\n// === APP_ROOT START ===\n// =======================\n// ----------------- APP ROOT ------------------\n@Composable\nfun ToiToiTourApp() {\n    val context = LocalContext.current\n    val scope = rememberCoroutineScope()\n    var stops by remember { mutableStateOf(demoStops) }\n\n    // ✅ Snackbar (poruke vozaču)\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // ✅ Places init + client\n    var placesClient by remember { mutableStateOf<PlacesClient?>(null) }\n    LaunchedEffect(Unit) {\n        try {\n            if (!Places.isInitialized()) {\n                Places.initialize(context.applicationContext, context.getString(R.string.google_maps_key))\n            }\n            placesClient = Places.createClient(context.applicationContext)\n        } catch (e: Exception) {\n            Log.e(\"ToiToiTour\", \"Places init error: ${e.message}\", e)\n            snackbarHostState.showSnackbar(\"Google Places nije inicijaliziran. Provjeri API key i Places API.\")\n        }\n    }\n\n    val launcher = rememberLauncherForActivityResult(\n        contract = ActivityResultContracts.GetContent()\n    ) { uri: Uri? ->\n        uri?.let {\n            val bytes = readPdfBytes(it, context)\n            if (bytes != null) {\n                uploadPdfToServer(\n                    context = context,\n                    pdfBytes = bytes,\n                    onStopsLoaded = { loaded -> stops = loaded },\n                    scope = scope\n                )\n            }\n        }\n    }\n\n    ToiToiTourScreen(\n        stops = stops,\n        onOpenPdf = { launcher.launch(\"application/pdf\") },\n        snackbarHostState = snackbarHostState,\n        placesClient = placesClient,\n        onAddStop = { newStop ->\n            stops = stops + newStop.copy(id = (stops.maxOfOrNull { it.id } ?: 0) + 1)\n        },\n        scope = scope\n    )\n}\n\n// =======================\n// === APP_ROOT END ===\n// =======================\n\n// =======================\n// === JSON_HELPERS START ===\n// =======================\n// ----------------- JSON HELPERS ------------------\nfun extractStopsFromJson(json: String): List<Stop> {\n    val s = json.trim()\n    if (s.isBlank()) return emptyList()\n\n    return try {\n        if (s.startsWith(\"[\")) {\n            val arr = JSONArray(s)\n            parseStopsFromArray(arr)\n        } else {\n            val obj = JSONObject(s)\n            val possibleKeys = listOf(\"items\", \"addresses\", \"stops\", \"data\", \"result\")\n            for (k in possibleKeys) {\n                if (obj.has(k) && obj.get(k) is JSONArray) {\n                    return parseStopsFromArray(obj.getJSONArray(k))\n                }\n            }\n            emptyList()\n        }\n    } catch (_: Exception) {\n        emptyList()\n    }\n}\n\nprivate fun parseStopsFromArray(arr: JSONArray): List<Stop> {\n    val out = ArrayList<Stop>()\n\n    for (i in 0 until arr.length()) {\n        val el = arr.get(i)\n\n        when (el) {\n            is JSONObject -> {\n                val street = el.optString(\"street\", \"\").trim()\n                val zip = el.optString(\"zip\", \"\").trim()\n                val city = el.optString(\"city\", \"\").trim()\n\n                val addressFallback =\n                    el.optString(\"address\", \"\").trim()\n                        .ifBlank { el.optString(\"full\", \"\").trim() }\n                        .ifBlank { el.optString(\"text\", \"\").trim() }\n                        .ifBlank { el.optString(\"line\", \"\").trim() }\n                        .ifBlank { el.optString(\"value\", \"\").trim() }\n\n                if (street.isNotBlank() && zip.isNotBlank() && city.isNotBlank()) {\n                    out.add(\n                        Stop(\n                            id = out.size + 1,\n                            title = street,\n                            cityLine = \"$zip $city\",\n                            location = null,\n                            source = \"PDF\"\n                        )\n                    )\n                } else if (addressFallback.isNotBlank()) {\n                    out.add(\n                        Stop(\n                            id = out.size + 1,\n                            title = addressFallback,\n                            cityLine = \"\",\n                            location = null,\n                            source = \"PDF\"\n                        )\n                    )\n                }\n            }\n\n            is String -> {\n                val addr = el.trim()\n                if (addr.isNotBlank()) {\n                    out.add(\n                        Stop(\n                            id = out.size + 1,\n                            title = addr,\n                            cityLine = \"\",\n                            location = null,\n                            source = \"PDF\"\n                        )\n                    )\n                }\n            }\n        }\n    }\n\n    return out\n}\n\n// =======================\n// === JSON_HELPERS END ===\n// =======================\n\n// =======================\n// === GEOCODE START ===\n// =======================\n// ----------------- GEOCODE (fallback) ------------------\nsuspend fun geocodeStops(\n    context: android.content.Context,\n    stops: List<Stop>\n): List<Stop> =\n    withContext(Dispatchers.IO) {\n        val geocoder = Geocoder(context, Locale.getDefault())\n\n        stops.map { stop ->\n            if (stop.location != null) return@map stop\n\n            try {\n                val query = buildString {\n                    append(stop.title)\n                    if (stop.cityLine.isNotBlank()) {\n                        append(\", \")\n                        append(stop.cityLine)\n                    }\n                    append(\", Germany\")\n                }\n                val results = geocoder.getFromLocationName(query, 1)\n                val r = results?.firstOrNull()\n                if (r != null) {\n                    stop.copy(location = LatLng(r.latitude, r.longitude))\n                } else stop\n            } catch (_: Exception) {\n                stop\n            }\n        }\n    }\n\n// =======================\n// === GEOCODE END ===\n// =======================\n\n// =======================\n// === NETWORK_PDF_IO START ===\n// =======================\n// ----------------- PDF HELPERS ------------------\nfun readPdfBytes(uri: Uri, context: android.content.Context): ByteArray? =\n    try {\n        Log.d(\"ToiToiTour\", \"PDF URI: $uri\")\n        val bytes = context.contentResolver.openInputStream(uri)?.use { it.readBytes() }\n        Log.d(\"ToiToiTour\", \"PDF bytes read: ${bytes?.size ?: -1}\")\n        bytes\n    } catch (e: Exception) {\n        Log.e(\"ToiToiTour\", \"readPdfBytes ERROR: ${e.message}\", e)\n        null\n    }\n\nfun uploadPdfToServer(\n    context: android.content.Context,\n    pdfBytes: ByteArray,\n    onStopsLoaded: (List<Stop>) -> Unit,\n    scope: kotlinx.coroutines.CoroutineScope\n) {\n    val client = OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(90, TimeUnit.SECONDS)\n        .writeTimeout(90, TimeUnit.SECONDS)\n        .build()\n\n    val tempFile = File.createTempFile(\"upload\", \".pdf\", context.cacheDir)\n    tempFile.writeBytes(pdfBytes)\n\n    val requestBody = MultipartBody.Builder()\n        .setType(MultipartBody.FORM)\n        .addFormDataPart(\n            \"file\",\n            \"upload.pdf\",\n            tempFile.asRequestBody(\"application/pdf\".toMediaType())\n        )\n        .build()\n\n    val request = Request.Builder()\n        .url(\"http://192.168.178.161:8080/extract\") // ne brisi ip pc\n        .post(requestBody)\n        .build()\n\n    Log.d(\"ToiToiTour\", \"UPLOAD -> ${request.url}\")\n\n    client.newCall(request).enqueue(object : Callback {\n        override fun onFailure(call: Call, e: java.io.IOException) {\n            tempFile.delete()\n            Log.e(\"ToiToiTour\", \"UPLOAD FAILED: ${e.message}\", e)\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            tempFile.delete()\n\n            val body = response.body?.string().orEmpty()\n            Log.d(\"ToiToiTour\", \"UPLOAD RESPONSE: code=${response.code} chars=${body.length}\")\n\n            if (!response.isSuccessful) {\n                Log.e(\"ToiToiTour\", \"UPLOAD NOT OK: code=${response.code} body=${body.take(200)}\")\n                return\n            }\n            if (body.isBlank()) {\n                Log.e(\"ToiToiTour\", \"UPLOAD EMPTY BODY\")\n                return\n            }\n\n            val baseStops = extractStopsFromJson(body)\n\n            Handler(Looper.getMainLooper()).post {\n                onStopsLoaded(baseStops)\n            }\n\n            scope.launch {\n                val withCoords = geocodeStops(context, baseStops)\n                onStopsLoaded(withCoords)\n            }\n        }\n    })\n}\n\n// =======================\n// === NETWORK_PDF_IO END ===\n// =======================\n\n// =======================\n// === PLACES_HELPERS START ===\n// =======================\n// ----------------- PLACES HELPERS ------------------\nprivate fun hasHouseNumber(address: String): Boolean {\n    return Regex(\"\\\\b\\\\d+\\\\b\").containsMatchIn(address)\n}\n\nprivate suspend fun findPredictions(\n    client: PlacesClient,\n    query: String\n): List<AutocompletePrediction> = suspendCancellableCoroutine { cont ->\n    val req = FindAutocompletePredictionsRequest.builder()\n        .setQuery(query)\n        .build()\n\n    client.findAutocompletePredictions(req)\n        .addOnSuccessListener { resp -> cont.resume(resp.autocompletePredictions) }\n        .addOnFailureListener { e -> cont.resumeWithException(e) }\n}\n\nprivate suspend fun fetchPlace(\n    client: PlacesClient,\n    placeId: String\n): Place = suspendCancellableCoroutine { cont ->\n    val fields = listOf(Place.Field.LAT_LNG, Place.Field.ADDRESS, Place.Field.NAME)\n    val req = FetchPlaceRequest.builder(placeId, fields).build()\n\n    client.fetchPlace(req)\n        .addOnSuccessListener { resp -> cont.resume(resp.place) }\n        .addOnFailureListener { e -> cont.resumeWithException(e) }\n}\n\n// =======================\n// === PLACES_HELPERS END ===\n// =======================\n\n// =======================\n// === NAV_HELPER START ===\n// =======================\n// ----------------- NAV HELPER ------------------\nprivate fun openGoogleNavigation(context: android.content.Context, stop: Stop) {\n    val q = buildString {\n        append(stop.title)\n        if (stop.cityLine.isNotBlank()) {\n            append(\", \")\n            append(stop.cityLine)\n        }\n    }\n\n    val gmmIntentUri = Uri.parse(\"google.navigation:q=\" + Uri.encode(q))\n    val mapIntent = android.content.Intent(android.content.Intent.ACTION_VIEW, gmmIntentUri).apply {\n        setPackage(\"com.google.android.apps.maps\")\n    }\n    context.startActivity(mapIntent)\n}\n\n// =======================\n// === NAV_HELPER END ===\n// =======================\n\n// =======================\n// === UI START ===\n// =======================\n// ----------------- UI ------------------\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ToiToiTourScreen(\n    stops: List<Stop>,\n    onOpenPdf: () -> Unit,\n    snackbarHostState: SnackbarHostState,\n    placesClient: PlacesClient?,\n    onAddStop: (Stop) -> Unit,\n    scope: kotlinx.coroutines.CoroutineScope\n) {\n    val context = LocalContext.current\n\n    var selectedStop by remember { mutableStateOf<Stop?>(null) }\n\n    // ✅ double click marker logika\n    var lastMarkerId by remember { mutableStateOf<Int?>(null) }\n    var lastMarkerClickMs by remember { mutableStateOf(0L) }\n\n    val cameraPositionState = rememberCameraPositionState {\n        position = CameraPosition.fromLatLngZoom(LatLng(47.7, 11.7), 11f)\n    }\n\n    // ✅ 3 stanja: Hidden -> PartiallyExpanded (peek) -> Expanded\n    val bottomSheetState = rememberStandardBottomSheetState(\n        initialValue = SheetValue.PartiallyExpanded,\n        skipHiddenState = false // ✅ omogući \"skroz zatvoreno\"\n    )\n    val sheetState = rememberBottomSheetScaffoldState(\n        bottomSheetState = bottomSheetState\n    )\n\n    var searchText by remember { mutableStateOf(\"\") }\n    var predictions by remember { mutableStateOf<List<AutocompletePrediction>>(emptyList()) }\n    var isSearching by remember { mutableStateOf(false) }\n    // =======================\n    // === BOTTOM_SHEET_SCAFFOLD START ===\n    // =======================\n    BottomSheetScaffold(\n        scaffoldState = sheetState,\n        sheetPeekHeight = 72.dp,\n        sheetDragHandle = { BottomSheetDefaults.DragHandle() },\n        snackbarHost = { SnackbarHost(snackbarHostState) },\n\n        // =======================\n        // === SHEET_CONTENT START ===\n        // =======================\n        sheetContent = {\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .fillMaxHeight(0.92f)\n            ) {\n                Column(\n                    modifier = Modifier.fillMaxWidth(),\n                    horizontalAlignment = Alignment.CenterHorizontally\n                ) {\n\n                    // =======================\n                    // === SEARCH_BLOCK START ===\n                    // =======================\n                    Column(\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .padding(horizontal = 12.dp)\n                    ) {\n                        OutlinedTextField(\n                            value = searchText,\n                            onValueChange = { v ->\n                                searchText = v\n                                if (v.trim().length < 3) {\n                                    predictions = emptyList()\n                                    return@OutlinedTextField\n                                }\n\n                                val c = placesClient ?: return@OutlinedTextField\n\n                                scope.launch {\n                                    isSearching = true\n                                    try {\n                                        predictions = findPredictions(c, v.trim())\n                                    } catch (e: Exception) {\n                                        Log.e(\"ToiToiTour\", \"Places predictions error: ${e.message}\", e)\n                                        snackbarHostState.showSnackbar(\"Google search error: ${e.message ?: \"unknown\"}\")\n                                    } finally {\n                                        isSearching = false\n                                    }\n                                }\n                            },\n                            modifier = Modifier.fillMaxWidth(),\n                            label = { Text(\"Traži adresu (Google)\") },\n                            singleLine = true\n                        )\n\n                        if (isSearching) {\n                            LinearProgressIndicator(modifier = Modifier.fillMaxWidth())\n                        }\n\n                        if (predictions.isNotEmpty()) {\n                            Card(\n                                modifier = Modifier\n                                    .fillMaxWidth()\n                                    .padding(top = 8.dp),\n                                shape = RoundedCornerShape(12.dp)\n                            ) {\n                                Column(modifier = Modifier.fillMaxWidth()) {\n                                    predictions.take(6).forEach { p ->\n                                        val primary = p.getPrimaryText(null).toString()\n                                        val secondary = p.getSecondaryText(null).toString()\n\n                                        Column(\n                                            modifier = Modifier\n                                                .fillMaxWidth()\n                                                .clickable {\n                                                    val c = placesClient ?: return@clickable\n                                                    scope.launch {\n                                                        try {\n                                                            val place = fetchPlace(c, p.placeId)\n                                                            val latLng = place.latLng\n                                                            val addr = (place.address ?: primary).trim()\n\n                                                            if (latLng == null || addr.isBlank()) {\n                                                                snackbarHostState.showSnackbar(\"Adresa nije pronađena (Google). Označi ručno.\")\n                                                                return@launch\n                                                            }\n\n                                                            if (!hasHouseNumber(addr)) {\n                                                                snackbarHostState.showSnackbar(\"Nema kućnog broja: koristi se lokacija ulice. Provjeri ručno.\")\n                                                            }\n\n                                                            onAddStop(\n                                                                Stop(\n                                                                    id = 0,\n                                                                    title = addr,\n                                                                    cityLine = \"\",\n                                                                    location = LatLng(latLng.latitude, latLng.longitude),\n                                                                    source = \"GOOGLE\"\n                                                                )\n                                                            )\n\n                                                            searchText = \"\"\n                                                            predictions = emptyList()\n\n                                                            cameraPositionState.position = CameraPosition.fromLatLngZoom(\n                                                                LatLng(latLng.latitude, latLng.longitude),\n                                                                14f\n                                                            )\n                                                        } catch (e: Exception) {\n                                                            Log.e(\"ToiToiTour\", \"FetchPlace error: ${e.message}\", e)\n                                                            snackbarHostState.showSnackbar(\"Ne mogu dohvatiti točku: ${e.message ?: \"unknown\"}\")\n                                                        }\n                                                    }\n                                                }\n                                                .padding(12.dp)\n                                        ) {\n                                            Text(primary, fontWeight = FontWeight.Bold)\n                                            if (secondary.isNotBlank()) Text(secondary, style = MaterialTheme.typography.bodySmall)\n                                        }\n                                        Divider()\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    // =======================\n                    // === SEARCH_BLOCK END ===\n                    // =======================\n\n                    // =======================\n                    // === SHEET_LIST_BLOCK START ===\n                    // =======================\n                    StopList(\n                        stops = stops,\n                        onStopNavigate = { s -> openGoogleNavigation(context, s) }\n                    )\n                    // =======================\n                    // === SHEET_LIST_BLOCK END ===\n                    // =======================\n                }\n            }\n        }\n        // =======================\n        // === SHEET_CONTENT END ===\n        // =======================\n    ) { padding ->\n\n        // =======================\n        // === MAP_CONTENT START ===\n        // =======================\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(padding)\n        ) {\n            Button(\n                onClick = onOpenPdf,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(12.dp)\n            ) {\n                Text(\"PDF öffnen\")\n            }\n\n            SelectedStopBar(\n                stop = selectedStop,\n                onNavigate = { s -> openGoogleNavigation(context, s) },\n                onClear = { selectedStop = null }\n            )\n\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f)\n            ) {\n                ToiToiMap(\n                    stops = stops,\n                    cameraPositionState = cameraPositionState,\n                    onMarkerClick = { stop, markerState ->\n                        val now = System.currentTimeMillis()\n                        val isDouble = (lastMarkerId == stop.id && (now - lastMarkerClickMs) < 650)\n\n                        lastMarkerId = stop.id\n                        lastMarkerClickMs = now\n\n                        selectedStop = stop\n                        markerState.showInfoWindow()\n\n                        if (isDouble) {\n                            scope.launch { sheetState.bottomSheetState.expand() }\n                        }\n                    }\n                )\n            }\n        }\n        // =======================\n        // === MAP_CONTENT END ===\n        // =======================\n    }\n\n// ✅ OVO JE BITNO: zatvori ToiToiTourScreen prije komponenti!\n}\n\n// =======================\n// === COMPONENT: SelectedStopBar START ===\n// =======================\n@Composable\nfun SelectedStopBar(\n    stop: Stop?,\n    onNavigate: (Stop) -> Unit,\n    onClear: () -> Unit\n) {\n    if (stop == null) return\n\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 12.dp, vertical = 6.dp),\n        shape = RoundedCornerShape(16.dp)\n    ) {\n        Row(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(12.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Column(modifier = Modifier.weight(1f)) {\n                Text(stop.title, fontWeight = FontWeight.Bold)\n                if (stop.cityLine.isNotBlank()) {\n                    Text(stop.cityLine)\n                }\n            }\n\n            Spacer(Modifier.width(8.dp))\n\n            Button(onClick = { onNavigate(stop) }) {\n                Text(\"Navigiraj\")\n            }\n\n            Spacer(Modifier.width(8.dp))\n\n            TextButton(onClick = onClear) {\n                Text(\"X\")\n            }\n        }\n    }\n}\n\n// =======================\n// === COMPONENT: SelectedStopBar END ===\n// =======================\n\n// =======================\n// === COMPONENT: ToiToiMap START ===\n// =======================\n@Composable\nfun ToiToiMap(\n    stops: List<Stop>,\n    cameraPositionState: CameraPositionState,\n    onMarkerClick: (Stop, MarkerState) -> Unit\n) {\n    GoogleMap(\n        modifier = Modifier.fillMaxSize(),\n        cameraPositionState = cameraPositionState,\n        uiSettings = MapUiSettings(\n            zoomControlsEnabled = false,      // ❌ makne +/-\n            myLocationButtonEnabled = false,\n            mapToolbarEnabled = false         // ❌ makne one 2 ikone (directions + maps)\n        )\n    ) {\n        stops.forEach { stop ->\n            val loc = stop.location ?: return@forEach\n            val markerState = remember(stop.id, loc) { MarkerState(position = loc) }\n\n            Marker(\n                state = markerState,\n                title = stop.title,\n                snippet = stop.cityLine,\n                onClick = {\n                    onMarkerClick(stop, markerState)\n                    true // mi kontroliramo klik (da ne otvara default gluposti)\n                }\n            )\n        }\n    }\n}\n// =======================\n// === COMPONENT: ToiToiMap END ===\n// =======================\n\n// =======================\n// === COMPONENT: StopList START ===idem \n// =======================\n@Composable\nfun StopList(\n    stops: List<Stop>,\n    onStopNavigate: (Stop) -> Unit\n) {\n    LazyColumn(\n        modifier = Modifier\n            .fillMaxWidth()\n            .heightIn(max = 450.dp)\n            .padding(16.dp)\n    ) {\n        itemsIndexed(stops) { index, stop ->\n            Column(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .clickable { onStopNavigate(stop) } // ✅ klik na listu = odmah navigacija\n                    .padding(8.dp)\n            ) {\n                Text(\"${index + 1}. ${stop.title}\", fontWeight = FontWeight.Bold)\n                if (stop.cityLine.isNotBlank()) Text(stop.cityLine)\n                Text(stop.source, style = MaterialTheme.typography.bodySmall)\n            }\n        }\n    }\n}\n// =======================\n// === COMPONENT: StopList END ===\n// ======================="}